syntax = "proto3";

option java_multiple_files = true;
option java_package = "io.grpc.examples.sp_ste";
option java_outer_classname = "sp_ste_proto";

option optimize_for = SPEED;

//This imports definitions from the commontypes.proto file, i don't need this
//right now so it is commented out
//import "CommonTypes.proto";

//The name of the package below is the name of the namespace for your functions
//except . is replaced with :: obviously
package sp.ste;

service sp_ste_control
{
   //This just checks that the connection is working and reads the sent values back
   rpc loopback(set_parameters) returns (parameter_values) {}
   //This just checks the current values of the parameter set
   rpc check_current_values(null_message) returns (parameter_values) {}
   //This does the setup for a single measurement and reads old values
   rpc issue_new_values_and_read_old(set_parameters) returns (parameter_values) {}
   //This does the setup for a single measurement and reads new values
   rpc issue_new_values_and_read_new(set_parameters) returns (parameter_values) {}
   //This launches a single measurement
   //rpc single_measurement (start_single) returns (single_ack) {}
   //This launches multiple measurements
   //rpc multiple_measurements (start_multiple) returns (multiple_ack) {}
}

/*
For strings, the default value is the empty string.
For bytes, the default value is empty bytes.
For bools, the default value is false.
For numeric types, the default value is zero.
For enums, the default value is the first defined enum value, which must be 0.
For message fields, the field is not set. Its exact value is language-dependent. See the generated code guide for details.
*/

//ENUMS
//enum values must be a int32 value
enum state
{
    option allow_alias = true;
    DISABLED = 0;
    OFF = 0;
    NOTRUNNING = 0;
    COMPLETE = 0;
    ENABLED = 1;
    ON = 1;
    RUNNING = 1;
    INCOMPLETE = 1;
}

//COMPOSITE TOP LEVEL MESSAGES
message set_parameters
{
   sp.ste.num_params num_params = 1;
   sp.ste.state_parameters state_parameters = 2;
   sp.ste.tx_parameters tx_parameters = 3;
   sp.ste.fft_parameters fft_parameters = 4;
   sp.ste.other_parameters other_parameters = 5;
}

message parameter_values
{
   sp.ste.num_params num_params = 1;
   sp.ste.state_parameters state_parameters = 2;
   sp.ste.tx_parameters tx_parameters = 3;
   sp.ste.fft_parameters fft_parameters = 4;
   sp.ste.other_parameters other_parameters = 5;
}

//SUB MESSAGE DEFINITIONS
message num_params
{
   uint32 count = 1;
}

message state_parameters
{
   bool save_iq = 1;
   state parameter_estimate_enable = 2;
   state awgn_enable = 3;
   state notch_enable = 4;
   state fft_a_enable = 5;
   state fft_b_enable = 6;
}

message tx_parameters
{
   double num_tx_samples_total = 1;
   double tx_freq1_Hz = 2;
   double tx_freq2_Hz = 3;
   double tx_phase1_rot = 4;
   double tx_phase2_rot = 5;
}

message fft_parameters
{
   uint32 fft_length_a = 1;
   uint32 fft_batches_a = 2;
   uint32 fft_length_b = 3;
   uint32 fft_batches_b = 4;
}

message other_parameters
{
   double num_rx_samples = 1;
   double rx_rot_freq_Hz = 2;
   uint32 decimation = 3;
   uint32 gain1 = 4;
   uint32 gain2 = 5;
   double nextTxStartTime = 6;
   double nextRxStartTime = 7;
}

message null_message
{

}
